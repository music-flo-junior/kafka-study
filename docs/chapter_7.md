# 챕터 7. 신뢰성 있는 데이터 전달

아파치 카프카는 신뢰성 있는 데이터 전달에 있어서 매우 유연하다. 웹사이트 클릭 추적(액션 로그)에서 부터 신용카드 결제에 이르기까지 많은 활용 사례가 있다.
이런 사례의 일부는 신뢰성을 필요로 하기도 하고, 처리 속도나 단순함을 우선시 하는 경우도 있다.
카프카는 매우 세세한 지점을 커스터마이징 가능하도록 개발되었다.

이렇게 유연성이 높은 만큼 사용하다 실수로 문제가 발생하기도 한다. 이 장에서는 어떠한 신뢰성이 있는지와 복제 매커니즘을 통해 시스템 신뢰성에 어떻게 영향을 미치는지 알아보자.


## 신뢰성 보장

잘 알려진 신뢰성 보장은 RDB가 기본적으로 제공하는 ACID(원자성, 일관성, 격리성, 지속성)을 의미한다. 어떠한 데이터 베이스가 ACID를 준수한다고 한다면, 그것은 트랜잭션 처리 관련해서 행동을 보장함을 의미한다.
신뢰성 있는 애플리케이션을 개발하고자 한다면 카프카가 제공하는 보장을 이해해야 한다. 

- 카프카는 파티션 내 메시지 간 순서를 보장한다, A 다음 B가 쓰여졌다면, 동일한 프로듀서가 동일한 파티션에 썼을 경우 카프카는 B의 오프셋이 A보다 큰것을 보장한다.
- 클라이언트가 쓴 메시지는 모든 인-싱크 레플리카의 파티션에 쓰여진 뒤에야 '커밋'된 것으로 간주한다. (acks option)
- 커밋된 메시지는 최소 1개의 레플리카가 있는 한 유실되지 않는다.
- 컨슈머는 커밋 된 메시지만 읽을 수 있다.

이런 기본적인 보장은 신뢰성 있는 시스템을 구축할 수 있지만 자체로는 완전하지 않다. 카프카는 개발자나 운영자가 설정 매개변수를 조절하므로 신뢰성을 조절할 수 있도록 개발되었다.

> #### Q. 카프카 메시지 순서 보장은 같은 파티션에만 적용될까?
> Kafka에서는 같은 파티션 내에서 메시지 순서는 보장되지만, 서로 다른 파티션 간의 메시지 순서는 **보장되지 않는다**.
> 메시지 순서를 보장하려면, 애플리케이션에서 키를 통해 제어하거나 커스텀 파티셔너로 같은 파티션에 들어갈 수 있도록 보장해야 한다.

## 복제 

카프카의 복제 매커니즘은 파티션별로 다수의 레플리카를 유지하는 특성과 함께 신뢰성 보장의 핵심이다. 하나의 메시지를 여러 레플리카로 관리하며 크래시가 발생하더라도 지속성을 유지한다.

- 각 토픽은 파티션으로 이루어진다.
- 파티션은 온라인/오프라인 상태일 수 있다.
- 각 파티션은 다수의 레플리카를 가질 수 있다. (이 중 하나가 리더가 된다)
- 모든 이벤트는 리더 레플리카에 쓰여지며, 리더 레플리카에서 읽혀진다.
- 다른 레플리카는 단순히 리더와 동기화를 맞추면서 최신 이벤트를 복사한다. 
- 리더가 작동 불능 상태가 되면 인-싱크 레플리카 중 하나가 리더가 된다.

**인-싱크 레플리카**는 아래 조건을 만족해야 한다.

- 주키퍼와 활성 세션이 있다. (6초 이내에 주키퍼로 하트비트를 전송했다.)
- 최근 10초 사이 리더로 부터 메시지를 읽어왔다.
- 최근 읽어온 메시지가 최신 메시지이다.

위 조건을 만족하지 못한다면. **아웃-오브-싱크 레플리카**로 전환된다. 동기화가 풀린 레플리카는 최근 메시지를 다시 따라잡으면 인-싱크 레플리카로 전환된다.

동기화가 살짝 늦은 인-싱크 레플리카는 프로듀서와 컨슈머를 느리게 만든다. 커밋되기 전 모든 인-싱크 레플리카가 해당 메시지를 받을때까지 기다리기 때문이다.

## 브로커 설정

브로커 설정은 브로커 단위에 적용되어 모든 토픽을 제어할수도 있고, 토픽 단위에서 적용할수도 있다. 이러한 구조를 통해 신뢰성이 필요한 토픽과 필요하지 않은 토픽을 구분한다.

### 복제 팩터

토픽 단위 설정은 `replication.factor`에. 자동으로 생성되는 토픽들에 적용되는 브로커 설정은 `default.replication.factor`에 설정한다.
복제 팩터가 N이면 N-1개의 브로커가 중단되더라도 토픽의 데이터를 읽거나 쓸 수 있다. 복제 팩터가 클수록 가용성과 신뢰성은 늘어나고 장애가 발생할 확률은 줄어든다.
반대로 복제 팩터가 N이라는 것은 N개 만큼의 브로커가 필요하다는 것이고, 디스크 공간도 필요하다. 가용성과 하드웨어 사이의 트레이드 오프다.

토픽에 몇개의 레플리카가 적당한지 결정을 어떻게 할 수 있을까? 아래는 핵심 고려 사항이다.

#### 가용성

레플리카가 하나라면 브로커를 재시작 하기만 해도 작동 불능에 빠진다. 레플리카가 많을수록 가용성은 늘어난다.

#### 지속성

각 레플리카는 파티션 안의 모든 데이터 복사본이다. 파티션에 레플리카가 하나 뿐 이라면 모든 데이터는 유실된다.

#### 처리량

레플리카카 추가 될 때마다 브로커 간 트래픽 역시 늘어난다.

#### 종단 지연

쓰여진 메시지를 컨슈머가 읽을 수 있으려면 모든 인-싱크 레플리카에 복제되어야 한다. 이론적으로 하나라도 느려지면 컨슈머까지 느려질 수 있다.

#### 비용

중요하지 않은 데이터에 대해 복제 팩터를 3으로 잡는 이유가 비용이다. 많은 레플리카를 가질 수록 비용이 증가한다.


### 언클린 리더 산출

이 설정은 클러스터 단위에서만 가능하다. 매개변수 이름은 `unclean.leader.election.enable`이고 기본 설정은 `false`이다.
파티션의 리더가 작동 불능에 빠졌을 경우 인-싱크 레플리카중 하나가 리더로 선출되는데. 인-싱크 레플리카가 없는 경우 **아웃-오브-싱크 레플리카**를 리더로 선출 될 수 있게 하는 옵션이다.

해당 기능을 활성화 할 경우 데이터 유실과 일관성 깨짐의 위험성을 수반한다. 

### 최소 인-싱크 레플리카

토픽과 브로커 단위 모두 `min.insync.replicas` 설정에서 잡아줄 수 있다.

토픽당 3개의 레플리카를 설정해도 인-싱크 레플리카는 하나만 남을 수 있다. 만약 이 레플리카가 작동 불능에 빠지면 가용성과 일관성 사이에서 하나를 골라야 한다.
여기서 문제는 카프카가 보장하는 신뢰성은 모든 인-싱크 레플리카에 쓰여진 시점에 커밋으로 간주한다. **'모든'이 단 한개의 레플리카를 의미할수도 있다!**

커밋된 데이터를 2개 이상의 레플리카에 쓰자고 한다면 해당 설정값을 2로 잡으면 된다. 이렇게 하면 프로듀서는 레플리카 중 인-싱크가 2개 이상 있는 파티션에만 쓸 수 있다.

### 레플리카를 인-싱크 상태로 유지하기

아웃-오브-싱크 레플리카는 전반적인 인쇠성을 낮추므로 가능한 피해야 한다. 카프카는 이 민감도를 조절할 수 있는 2가지 옵션을 제공한다.

`zookeeper.session.timeout.ms`는 카프카 브로커가 주키퍼로 하트비트 전송을 멈출 수 있는 최대 시간을 정의한다. 이 시간 안에만 하트비트를 전송하면 브로커가 죽었다고 판단하지 않는다.

`replica.lag.time.max.ms`에 설정 된 값보다 오래 리더에서 데이터를 읽지 못하면(최신 메시지를 따라잡지 못하면) 동기화가 풀려 아웃-오브-싱크 레플리카로 전환된다.

### 디스크에 저장하기

카프카는 메시지를 받은 레플리카의 수에만 의존하고 디스크에 저장되지 않은 메시지에 대해서도 응답한다. 카프카는 세그먼트를 교체할 때와 재시작 할때만 메시지를 디스크로 **플러시**한다.
그 외의 경우에는 모두 리눅스의 페이지 캐시에 의존한다.

이런 플러시 주기를 `flush.messages` 설정 매개 변수를 통해 조절할 수 있다.

## 신뢰성 있는 시스템에서 프로듀서 사용하기

사용 가능한 하장 높은 신뢰성 설정을 브로커에 적용해도 프로듀서 역시 설정을 해야한다.

- 신뢰성 요구 조건에 맞는 올바른 acks 설정을 사용한다.
- 설정과 코드 모두에서 에러를 올바르게 처리한다.

### 응답 보내기

프로듀서는 아래 세가지 모드 중 하나를 선택할 수 있다.

`ack=0`
- 프로듀서가 네트워크로 메시지를 전송 한 시점에서 메시지가 정상적으로 쓰여진 시점부터 성공으로 간주한다.

`ack=1`
- 리더가 메시지를 받아서 파티션 데이터 파일에 쓴 직후 응답 혹은 에러를 발생시킨다. 클라이언트로 응답이 간 이후 팔로워로 복제 되기 전 크래시가 발생한다면 데이터 유실이 있을 수 있다.
- 메시지 복제 속도보다 더 빨리 리더에 쓸 수 있어 불완전 복제 파티션이 발생할 수 있다.

`ack=all`
- 리더가 모든 인-싱크 레플리카가 메시지를 받아갈 때 까지 기다렸다가 응답한다. 응답이 오기 전까지 얼마나 많은 레플리카에 메시지가 복제 될 것인지 조절할 수 있게 한다.

### 프로듀서 재시도 설정하기

프로듀서는 재시도 가능한 에러를 처리할 수 있다. 재시도 가능한 에러 코드를 받았을 경우 프로듀서는 전송을 재시도 할 것이다.
예를 들어, `LEADER_NOT_AVAILABLE` 메시지 같은 경우는 재시도 후 리더가 선정되면 재처리 될 것이다.

### 추가적인 에러 처리

개발자 입장에서는 다른 에러 코드도 처리해야 할 때가 있다. 

- 메시지 크기에 관련되었거나 인가 관련 에러 같이 재시도 불가능한 에러
- 메시지가 브로커에 전송 되기 전 발생한 에러
- 프로듀서가 재시도 시도를 모두 소진한 경우
- 타임아웃

이런 에러 핸들은 애플리케이션 성격에 따라 나뉜다. 폐기를 할 수도 있고, 에러를 로깅할 수도 있다.

## 신뢰성 있는 시스템에서 컨슈머 사용하기

컨슈머는 카프카에 커밋 된 데이터만 읽을 수 있다. 모든 인-싱크 레플리카에 쓰여진 다음부터 읽을 수 있는 것이다. 다르게 말하면 컨슈머는 일관성이 보장되는 데이터만 읽는다.
컨슈머는 메시지를 배치 단위로 읽은 후 마지막 오프셋을 확인하고 브로커로부터 받은 마지막 오프셋 값에서 시작하는 다른 메시지 배치를 요청한다. 이렇게 하므로 메시지 누락 없이 데이터를 올바른 순서로 읽는다.

특정 컨슈머가 동작을 정지하면 또 다른 컨슈머는 어디서부터 작업을 재개해야 하는지 알아야 한다. 이전 컨슈머가 정지하기 전 마지막으로 읽은 오프셋을 알아야 한다.
컨슈머가 오프셋을 커밋해야 하는 이유가 여기에 있다. 읽고 있던 파티션에 대해 어디까지 읽었는지를 저장해 두어야 한다. 컨슈머가 메시지를 누락하는 경우는 읽었으나 처리를 완료하지 않은 오프셋을 커밋하는 경우다.

### 신뢰성 있는 처리를 위해 중요한 컨슈머 설정

원하는 수준의 신뢰성을 갖는 컨슈머를 설정하기 위해 알아두어야 하는 컨슈머 속성은 4개가 있다.

`group.id`
- 같은 그룹 아이디를 갖는 두개의 컨슈머가 같은 토픽을 구독할 경우, 각각의 컨슈머에슨 해당 토픽 전체 파티션의 서로 다른 부분 집합이 할당된다.

`auto.offset.reset`
- 커밋 된 오프셋이 없을 때나 컨슈머가 브로커에 없는 오프셋을 요청할 때 컨슈머가 해야할일을 결정한다.
- **earliest**: 유효한 오프셋이 없는 한 컨슈머는 파티션의 맨 앞에서 부터 데이터를 읽는다.
- **lastst**: 파티션의 끝부터 읽는다.

`enable.auto.commit`
- 일정한 시간에 맞춰 컨슈머가 알아서 오프셋을 커밋하게 할 것인가를 결정한다. 해당 설정이 off라면 애플리케이션에서 오프셋을 직접 커밋해야 한다. 주된 단점은 메시지 중복 처리를 제어할 수 없다.

`auto.commit.interval.ms`
- 오토커밋을 사용할 경우 커밋되는 주기를 설정할 수 있다. 기본적으로 5초마다 커밋하도록 동작한다.

### 컨슈머에서 명시적으로 오프셋 커밋하기

1. 메시지 처리를 먼저하고 오프셋 커밋은 나중에
- 스레드가 두개 이상 있거나 상태가 있는 처리가 필요한 경우 컨슈머 객체가 thread-safe 하지 않기 때문에 오프셋 커밋을 나중으로 미루자.

2. 커밋 빈도는 성능과 크래시 발생시 중복 개수 사이의 트레이드 오프다
- 루프 안에서 여러번 커밋하거나 루프가 몇번 지나가고 커밋하는 사이에서 선택할 수 있다. 커밋 작업은 오버헤드를 발생시킨다. 

3. 정확한 시점에 오프셋을 커밋하자
- 흔히 하는 실수는 마지막으로 처리 된 오프셋을 커밋하는게 아닌 마지막으로 읽어 온 메시지의 오프셋을 커밋하는 것이다. 처리 완료 된 메시지의 오프셋을 커밋하라.

4. 리밸런스 발생을 염두하여 적절히 처리하자
- 리밸런스는 항상 발생할 것을 염두하라. 이것을 적절히 처리해줄 필요가 있다.

5. 컨슈머는 재시도를 해야할 수 있다.
- poll 호출 후 레코드를 처리한 뒤 일부 레코드는 처리되지 않아 나중에 처리되어야 할 수 있다. 카프카 컨슈머는 각각의 메시지에 응답하지 않고 오프셋 번호로 응답한다.
- #30 처리가 실패 한 상황에서 #31을 커밋하면 안된다. #30도 처리된것으로 간주된다.
- 컨슈머의 pause 메서드를 호출해서 추가적인 poll 호출을 막고 레코드 처리를 계속하거나 별도의 토픽에 쓴 뒤 계속 진행하라.

6. 컨슈머가 상태를 유지해야 할 수 있다. 
- 애플리케이션에 따라서 컨슈머가 메서드 호출 간 상태를 유지하는 경우도 있다. 프로세스가 재시작된다면 마지막 오프셋으로부터 읽어서 할 수 없는 경우가 있다. 
- 이럴때는 상태를 별도의 토픽에 써라. 그렇다면 그 토픽을 통해 데이털르 유지할 수 있다.

## 시스템 신뢰성 검증하기

(검증을 하기 위한 관련 툴을 소개한다. 툴은.. 그냥 책을 참고하자)