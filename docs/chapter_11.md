# 챕터 11. 보안

## 보안 설정 적용하기

카프카는 데이터의 기밀성, 진실성, 가용성을 보장하기 위해 아래와 같은 절차를 사용한다.

- 인증은 사용자가 **누구**인지 식별한다.
- 인가는 사용자가 **무엇**을 할 수 있는지 결정한다.
- 암호화는 누설과 위조로 부터 데이터를 **보호**한다
- 감사는 사용자가 무엇을 했는지, 하려 했는지를 **추적**한다.
- 쿼터는 자원을 얼마나 사용할 수 있는지를 **조절**한다.

안전한 카프카 클러스터는 다음과 같은 특징을 가진다.

- 클라이언트 진정성: 전송된 메시지가 실제 사용자로부터 온 것인지 인증한다.
- 서버 진정성: 리더 브로커로 메시지를 보내기 전에 실제 브로커와 맺어진 것인지 검증한다.
- 기밀성: 메시지가 전달되는 도중에 있는 모든 연결은 암호화 되거나 물리적으로 보호되어야 한다.
- 무결성: 안전하지 못한 네트워크를 통해 전송되는 모든 데이터에 메시지 다이제스트를 포함하여 변조 시 알아차릴 수 있어야 한다.
- 접근 제어: 메시지에 로그를 쓰기 전에 사용자가 읽기/쓰기 권한이 있는지를 확인해야 한다.
- 감사 가능성: 감사용 기록이 남아야 한다.
- 가용성: 몇몇 사용자가 대역폭을 혼자 독차지하거나 브로커에서 DDOS를 방지하기 위해 쿼터와 제한을 두어야 한다.

위와 같은 특징을 보장할 수 있는 카프카의 보안 기능에 대해 살펴보자.

## 보안 프로토콜

카프카 브로커에는 한 개 이상의 엔드포인트를 가진 리스너 설정이 있다. 클라이언트로부터 연결을 받는 것이 리스너다. 각각의 리스너는 각각의 보안 설정을 가질 수 있다.
카프카는 두개의 표준 기술 (TLS, SASL)을 사용하여 4개의 보안 프로토콜을 지원한다. 

### PLAINTEXT 

해당 방식에서는 인증이 존재하지 않는다, 사설 네트워크 안에서 인증이나 암호화가 필요없을 정도로 민감하지 않은 정보를 처리할 때 사용한다.

### SSL

선택적으로 클라이언트 SSL 인증을 수행할 수 있다. 암호화 뿐 아니라 클라이언트/서버 인증도 지원하기에 안전하지 않은 네트워크에도 적절하다.

### SASL_PLAINTEXT

SASL 인증과 PLAINTEXT 전송 계층이 합쳐진 것 이다. 어떠한 매커니즘은 서버 인증 역시 지원한다. 암호화는 지원하지 않는다.

### SASL_SSL

SASL 인증과 SSL 전송 계층이 합쳐진 것 이다. 암호화 뿐만 아니라 클라이언트/서버 인증도 지원한다.

> #### SASL
> - **SASL**은 네트워크 프로토콜에서 인증과 보안을 제공하는 **프레임워크**다.
> - PLAIN, SCRAM, OAuth 등 다양한 **인증 메커니즘**을 지원 한다.
> - 보안과 확장성이 뛰어나며, 클라이언트-서버 간 **유연한 인증**을 가능하게 한다.

## 인증

인증은 서버와 클라이언트 사이에서 서로의 신원을 확인하는 절차다. 클라이언트가 서버에게 신원을 제공하므로써 검증을 수행한다.

### SSL

카프카 리스너의 보안 프로토콜이 SSL, SASL_SSL로 설정되었을 경우, 해당 리스너로의 연결에 TLS 보안 전송 계층이 사용횐다.
클라이언트는 서버의 신원을 확인하기 위해 서버의 인증서를 검증한다. 만약 SSL을 사용한 **클라이언트 인증 기능이 활성화** 되어 있다면 **서버 역시 클라이언트의 인증서를 검증**하여 신원을 확인한다.

> #### SSL 방식에서의 인증
> 기본적으로 클라이언트가 서버의 신원을 확인한다.(신뢰할 수 있는 CA 기반의 인증서)
> 다만 클라이언트 인증을 사용한다면, 서버 또한 클라이언트 인증서의 CA를 확인하여 인증을 처리한다.

### SASL

카프카 프로토콜은 SASL을 이용한 사용자 인증을 지원한다. 전송 계층에 SASL과 SSL을 같이 사용하여 인증과 암호화를 동시에 지원하는 안전한 채널도 사용할 수 있다.
SASL 인증은 서버가 챌린지를 내놓으면 클라이언트가 여기에 응답을 보내는 과정을 일정한 순서로 진행한다.

#### SASL/GSSAPI

케로베로스는 널리 사용되는 네트워크 인증 프로토콜이다. 불안전환 네트워크에서의 상호 인증을 구현하기 위해 강력한 암호화 기능을 사용한다.
GSSAPI는 케로베로스 V5 메커니즘을 사용해서 인증을 수행한다.

#### SASL/PLAIN

TLS와 함께 사용할 수 있는 단순한 이름/비밀번호 인증 메커니즘을 정의한다. 클라이언트가 인증 과정에서 이름/비밀번호를 서버로 보내면 서버는 비밀번호 저장소에 있는 값을 사용해서 비밀번호를 검증한다.

#### SASL/SCRAM

PLAIN의 비밀번호를 직접 전송하는 메커니즘의 보안 문제를 해결할 수 있는 안전한 인증 메커니즘을 제공한다. 암호화 되지 않은 비밀번호가 전송되는 것을 피하고 다른 사용자로 가장해서 내용을 읽어오는 것을 방지한다.

#### SASL/OAUTHBEARER

OAuth는 애플리케이션이 HTTP 서비스에 대해 제한된 접근 권한을 획득 할 수 있도록 해주는 인가 프레임워크다. 이를 통해 얻은 자격 증명을 사용해서 Not HTTP 프로토콜에 대해 접근할 수 있게 해준다.

#### 위임 토큰

위임 토큰은 카프카 브로커와 클라이언트 사이에 공유 된 `비밀`이다. SSL 키스토어나 케로베로스 키탭 파일을 배포할 필요 없는 경량 설정 매커니즘을 제공한다.
각각의 토큰은 토큰 식별자와 공유된 비밀로 사용될 해시 기반 메시지 인증 코드로 이루어져 있다. 이러한 위임 토큰은 `SASL/SCRAM`로 인증된다.

### 재인증

카프카 브로커는 새로운 연결을 맺는 시점에 인증을 수행한다. 케로베로스나 OAuth 같은 인증 방식은 유효기간이 존재한다. 카프카는 기존 자격 증명이 만료되기 전 새로운 자격 증명을 얻어오기 위해 백그라운드 로그인 스레드를 사용한다.
자격증명은 기본적으로 **새로운 연결에만 적용**된다. 예전 자격 증명을 사용해 인증한 연결들은 타임아웃 발생 전까지 유지된다. 

카프카 브로커는 `connections.max.reauth.ms` 값을 통해 연결을 재인증 할 수 있도록 한다. 이 옵션을 설정을 0 이상으로 잡아주면 SASL 연결의 수명을 체크하고 있다가. 핸드쉐이크를 수행할 때 남은 수명을 알려준다.
이 기간동안 재인증을 하지 않으면 연결을 강제로 종료한다. 

### 무중단 보안 업데이트

비밀번호를 순환시키거나, 보안 패치를 적용하거나, 보안 프로토콜을 업데이트 하거나 하기 위해 정기적으로 카프카를 정비해야 한다. 
많은 작업이 롤링 업데이트를 통해 이루어진다. SSL 키스토어나 트러스트스토어를 업데이트 하는 것은 브로커를 재시작 할 필요 없이 동적 업데이트를 할 수 있다.

사용중인 클러스터에 새로운 보안 프로토콜을 추가할 때는 브로커에 오래된 프로토콜을 사용하는 기존 리스너는 그대로 두고, 새 프로토콜을 사용하는 새로운 리스너를 추가하므로써, 클라이언트가 오래 된 리스너를 사용해 접근할 수 있도록 한다.

1. 카프카 설정 툴을 사용해 새로운 리스너를 추가한다.
2. 클라이언트가 신규 리스너를 사용하도록 수정한다.
3. 설정 툴을 사용해서 예전 리스너를 제거한다.

## 암호화

암호화는 데이터 무결성을 위해 사용된다. SSL, SASL_SSL 보안 프로토콜을 사용하는 카프카 리스너는 전송계층에 TLS를 적용하여 암호화 된 채널을 사용할 수 있다.

디스크에 대해서도 암호화를 적용할 수 있다. 전체 디스크 암호화나 볼륨 암호화를 사용해 물리 저장 장치 자체를 암호화 하면 된다.

많은 경우 전송 계층 암호화나 데이터 저장소 암호화 정도로 충분한 보호 조치가 되지만, 플랫폼 운영자에게 데이터 접근 권한을 자동으로 부여하는 문제를 피하기 위해 추가적인 조치가 필요할 수 있다.
힙 덤프에서 데이터가 보일 수도 있고, 운영자가 직접 열어볼수도 있다. 

### 종단 암호화

시리얼라이저나 디시리얼라이저가 직렬화 도중에 메시지를 암호화 하거나 복호화 하도록 설정할 수 있다. 대개 AES와 같은 대칭 키 알고리즘을 사용한다. 키 관리 시스템 (KMS)를 사용하므로써 공유 키를 저장하고, 프로듀서는 암호화, 컨슈머는 복호화를 수행한다.

## 인가

인가는 사용자가 자원에 대해 어떤작동을 수행할 수 있는지를 결정하는 절차다. 카프카 브로커는 커스터마이즈가 가능한 권한 부여자를 사용하여 접근 제어를 관리한다.
클라이언트에서 브로커로의 연결이 맺어질 때마다 브로커는 클라이언트를 인증하고 클라이언트의 신원을 가리키는 `KafkaPrincipal`을 해당 연결에 결부시킨다. 그리고 요청이 처리될 때 마다 요청을 수행할 수 있을지 검증한다.

### AclAuthorizer

AclAuthorizer는 접근 제어 목록을 사용해서 카프카 자원에 대한 접근을 관리한다. 주키퍼에 저장되고, 브로커가 시작될때 메모리에 캐시된다.

### 인가 기능 커스터마이즈

카프카의 인가 기능을 커스터마이즈해서 추가적인 접근 제한을 설정하거나 역할 기반 접근 제어와 같은 새로운 유형의 접근 제어를 추가할 수 있다.

## 감사

감사와 디버깅을 목적으로 log4j 로그를 생성하도록 카프카 브로커를 설정할 수 있다. 로깅 레벨 뿐 아니라 어펜더 각각에 대한 설정도 가능하다.
감사 목적의 로그를 남기기 위해서는 인가를 로깅하는 `kafka.authorizer.logger`와 `kafka.request.logger`에 대해 로그 레벨과 보존 기한을 따로 설정해야 한다. 
이런 로그를 분석하고 시각화 하기 위해 Elastic Stack과 같은 프레임워크를 사용할 수 있다.

## 주키퍼 보안

(카프카 보안과 비슷한 SASL, TLS를 통함, 필요 시 찾아보면 될듯)