### 챕터 3. 카프카 프로듀서: 카프카에 메시지 쓰기

- 추천 : https://www.youtube.com/watch?v=geMtm17ofPY

### 3.1 프로듀서 개요
애플리케이션이 카프카에 메시지를 써야 하는 상황에는 여러 가지가 있을 수 있다.
- 감사 혹은 목적으로 한 사용자 행동 기록
- 성능 매트릭 기록
- 로그 메시지 저장 (청취로그, 인스턴스 로그 수집)
- 다른 애플리케이션과 비동기적 통신 수행 (금칙어)
- 임의의 정보를 데이터베이스에 저장하기 전 버퍼링 (티켓 발권..개발..시?)

이러한 사용 사례들은 목적이 다양한 만큼 요구 조건 역시 다양핟다.

- 모든 메시지가 중요해서 메시지 유실이 용납되지 않는지? 아니면 유실을 허용되는지?
- 중복이 허용되는지?
- 반드시 지켜야 할 지연이나 처리율이 있는지?

[ 카프카 프로듀서 요소 ]

![image](https://github.com/user-attachments/assets/ff33e0b0-7538-47c4-809f-955a47f9c2e3)


1. ProduceRecord

- 카프카에 메시지를 쓰는 작업은 ProduceRecord 객체 생성이 시작점이다.
- 레코드가 저장될 토픽과 밸류 지정은 필수 사항이지만 키와 파티션 지정은 선택사항이다.

2. Serializer
- ProduceRecord를 전송하는 API를 호출했을 때 프로듀서가 가장 먼저 하는 일은 키와 객체가 네트워크 상에서 전송될 수 있도록 직렬화해서 바이트 배열로 변환하는 과정이다.

3. 파티셔너
- 그 다음에, 파티션을 명시적으로 지정하지 않았다면 해당 데이터를 파티셔너에게로 보낸다.
- 퍄티셔너가 파티션을 결정하는 기준은 ProduceRecord 객체의 키 값이다.

4. 레코드 배치
- 파티션이 결정되어 메시지가 전송될 토픽과 파티션이 확정되면 프로듀서는 이 레코드를 같은 토픽 파티션으로 전송될 레코드를 모은 레코드 배치에 추가한다.
- 별도의 스레드가 이 레코드 배치를 적절한 카프카 브로커에게 전송한다.

5. 응답
- 브로커가 메시지를 받으면 응답을 돌려준다.
- 메시지가 성공적으로 저장되었을 경우, 브로커는 토픽, 파티션, 그리고 해당 파티션 안에서의 레코드의 오프셋을 담은 RecordMetadata 객체를 리턴한다.
- 메시지 저장에 실패했을 경우, 에러가 리턴되며 몇 번 더 재전송을 시도할 수 있다. (retry 관련 설정이 있을듯??)

### 3.2 카프카 프로듀서 생성하기

카프카 프로듀서는 3개의 필수 속성값을 갖는다.

1. bootstrap.servers
- 카프카 클러스터와 첫 연결을 생성하기 위해 프로듀서가 사용할 브로커의 host:port 목록
- 모든 브로커를 포함할 필요는 없고, 프로듀서가 첫 연결을 생성한 뒤 추가 정보를 받아오기 때문에 연결할 브로커를 정의하면 된다.
- 다만, 브로커가 작동을 정지하는 경우에도 클러스터와 연결을 유지할 수 있도록 최소 2개 이상 지정할 것을 권장한다.

2. key.serializer
- 카프카에 쓸 레코드의 키값을 직렬화하기 위해 사용하는 시리얼라이저 클래스 이름이다.
- 카프카 브로커는 메시지의 키깂, 벨류값으로 바이트 배열을 받는다.
- 프로듀서는 key.serializer에 정의된 시리얼라이저로 전달해야하는 키 값을 바이트 배열로 변경한다.
- ex) ByteArraySerializer / StringSerializer / IntegerSerializer
- (보통 실무에서 StringSerializer을 사용했는데.. 다른 거 사용해본 적 있는 사람~~?)
- 키값 없이 벨류만 보낼 때도 key.serializer 설정을 VoidSerializer를 사용해서 키 타입으로 Void 타입을 설정한다.

3. value.serializer
- 카프카에 쓸 레코드의 벨류값을 직렬화하기 위해 사용하는 시리얼라이저 클래스의 이름이다.

프로듀서 메시지 전송 방법에는 크게 3가지 방법이 있다.

1. 파이어 앤 포겟 (Fire and Forget)
- 메시지를 서버에 전송만 하고 성공 혹은 실패 여부에는 신경 쓰지 않는다.
- 메시지 유실 가능성이 있음

2. 동기적 전송 (Synchronous send)
- 카프카 프로듀서는 언제나 비동기적으로 작동하나, Future get() 메서드를 호출해서 작업이 완료될 때까지 기다렸다가 실제 성공 여부를 확인하면 동기적 전송이 가능하다.

3. 비동기적 전송 (Asynchronous send)
- 콜백 함수와 함께 send() 메서드를 호출하면 카프카 브로커로부터 응답을 받는 시점에 자동으로 콜백 함수가 호출된다.

### 3.4 카프카 프로듀서 설정하기

필수 설정 외에 메모리 사용량이나 성능, 신뢰성 등에 상당한 영향을 주는 설정을 살펴보자.

#### 3.4.1 client.id
- 프로듀서와 그것을 사용하는 애플리케이션을 구분하기 위한 논리적 식별자.
- 임의의 문자열을 사용
- 브로커는 프로듀서가 보내온 메시지를 서로 구분하기 위해 이 값을 사용한다.
  -> 로그 메시지 출력 / 성능 메트릭 집계 / 트러블 슈팅 시 활용 등...

#### 3.4.2 acks
- 프로듀서가 임의의 쓰기 작업이 성공했다고 판별하기 위해 얼마나 많은 파티션 레플리카가 해당 레코드를 받아야 하는지 결정한다.
- 기본 값 : acks=all (v3.0)  (이전 버전에서는 acks=1 이었던듯?)
1. acks=0 일 때
- 프로튜서는 메시지가 성공적으로 전달되었다고 간주하고 브로커의 응답을 기다리지 않는다.
- 메시지 유실 가능성이 있으며, 높은 처리량을 제공한다.

2. acks=1 일 때
- 프로듀서는 리더 레플리카가 메시지를 받는 순간 브로커로부터 성공했다는 응답을 받는다.
- 만약 리더에 메시지를 쓸 수 없다면(리더에 크래시가 났는데 새 리더는 아직 선출되지 않은 상태) 프로듀서는 에러 응답을 받을 것이고 데이터 유실을 피하기 위해 메시지 재전송을 시도하게 된다.
- 크래시가 난 상태에서 메시지가 복제가 안 된 채로 새 리더가 선출된 경우에는 메시지가 유실될 수 있다.

3. acks=all 일 때
- 프로듀서는 메시지가 모든 인-싱크 레플리카에 전달된 뒤에야 브로커로 부터 성공했다는 응답을 받는다.

#### 3.4.3 메시지 전달 시간

![image](https://github.com/user-attachments/assets/a5a9fc30-6f94-4ff9-9dfd-e6beea381bc1)

1. max.block.ms
- 프로듀서가 얼마나 오랫동안 블록되는지 결정한다.
- 프로듀서가 send() 호출 했을 때 (-partitionsFor를 호출해서 명시적으로 메타데이터를 요청했을 때), 블록된 경우 max.block.ms 만큼 시간이 흐르면 예외가 발생한다.
- 전송 버퍼가 가득 차거나 메타데이터가 아직 사용 가능하지 않을 때 블록된다.

2. delivery.timeout.ms
- 레코드 전송 준비가 완료된 시점(즉, send()가 문제없이 리턴되고 레코드가 배치에 저장된 시점)에서부터 브로커의 응답을 받거나 아니면 전송을 포기하게 되는 시점까지의 제한시간을 지정한다.
- delivery.timeout.ms >= linger.ms + retry.backoff.ms + request.timeout.ms

3. request.ms
- 프로듀서가 데이터를 전송할 때 서버로부터 응답을 받기 위해 얼마나 기다릴 것인지를 결정한다.
- 재시도 시간이나, 실제 전송 이전에 소요되는 시간 등을 포함하지 않는다.

4. retries, retry.backoff.ms
- retries : 프로듀서 메시지 전송 에러 발생 시, 메시지 재전송하는 횟수
- retry.backoff.ms : 재시도 사이에 대기하는 시간 (기본값 : 100ms)

#### 3.4.4 linger.ms
- 현재 배치를 전송하기 전까지 대기하는 시간을 결정한다.
- 프로듀서는 현재 배치가 가득차거나 ligner.ms에 설정된 제한 시간이 되었을 때 메시지 배치를 전송한다.
- 기본적으로 프로듀서는 메시지 전송에 사용할 수 있는 스레드가 있을 때 곧바로 전송하도록 되어 있다.
- linger.ms를 0보다 큰 값으로 설정하면 프로듀서가 브로커에 메시지 배치를 전송하기 전에 대기한다.
  -> 지연 증가 / 처리율 크게 증대

#### 3.4.5 buffer.memory
- 프로듀서가 메시지를 전송하기 전에 메시지를 대기시키는 버퍼의 크기를 결정한다.

#### 3.4.6 compression.type
- 메시지 압축 알고리즘을 설정한다. -> snappy / gzip / lz4 / zstd

#### 3.4.7 batch.size
- 레코드 배치에 사용될 메모리의 양을 결정한다.

#### 3.4.8 max.in.flight.request.per.connection
- 프로듀서가 서버로 부터 응답을 받지 못한 상태에서 전송할 수 있는 최대 메시지의 수

#### 3.4.9 max.request.size
- 프로듀서가 전송하는 쓰기 요청의 크기
- 브로커 message.max.bytes 와 동일하게 맞춘다.

#### 3.4.10 receive.buffer.bytes, send.buffer.bytes
- 데이터를 읽거나 쓸 때 소켓이 사용하는 TCP 송수신 버퍼의 크기를 결정한다.

#### 3.4.11 enable.idempotence
- idempotence(멱등성) : 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질, 연산을 여러 번 반복하여도 한 번만 수행된 것과 같은 성질
- 카프카 브로커에 메시지 중복 전송 허용 유부 값이다.
- true 로 설정할 경우, 프로듀서는 레코드를 보낼 때 마다 순차적인 번호를 붙여서 보내고 동일한 번호를 가진 레코드를 2개 이상 받을 경우 하나만 저장한다.

### 3.5 시리얼라이저

프로듀서는 반드시 시리얼라이저를 지정해주어야 하며, 정의된 타입말고 커스텀 시리얼라이저가 필요한 경우가 있다.

커스텀 시리얼라이저에 대해 알아보자.

#### 3.5.1 커스텀 시리얼라이저

카프카로 전송해야 하는 객체가 단순한 문자열이나 정숫값이 아닐 경우에는 두 가지의 선택지가 있다.

1. 레코드를 생성하기 위해 에어브로, 스리프트, 프로토버프와 같은 범용 직렬화 라이브러리를 사용한다.
2. 사용하고 있는 객체를 직렬화하기 위한 커스텀 직렬화 로직을 작성한다. (비효율적인 개발 필요)

#### 3.5.2 아파치 에이브로를 사용해서 직렬화하기

- 추천 : https://musimkyung.tistory.com/17


- 아파치 에이브로는 언어 중립적인 데이터 직렬화 형식이다.
- 에이브로 데이터는 언어에 독립적인 스키마의 형태로 기술된다.
- 이 스키마는 보통 JSON 형식으로 정의 되며, 주어진 데이터를 스키마에 따라 직렬화하면 이진 파일 형태로 결과물이 뽑혀 나오는 것이 보통이다.
- 직렬화된 결과물이 저장된 파일을 읽거나 직렬화를 할 때 스키마 정보가 별도로 주어진다고 가정하고, 보통은 에이브로 파일 자체에 스키마를 내장하는 방법을 쓴다.


- 에이브로가 카프카와 같은 메시지 전달 시스템에 사용하는데 적합한 이유는?
  -> 애플리케이션이 새로운 스키마로 전환하더라도 기존 스키마와 호환성을 유지하는 한, 데이터를 읽는 애플리케이션은 일체의 변경 없이 계속해서 메시지를 처리할 수 있다.

#### 3.5.3 카프카에서 에이브로 레코드 사용하기

- 카프카 레코드 내에 전체 스키마를 저장하는 경우, 전체 레코드 사이즈는 2배 이상이 될 수 있다.
- 따라서 카프카는 스키마 레지스트리라 불리는 아키텍처 패턴을 사용한다.
- 카프카에 데이터를 쓰기 위해 모든 스카마를 레지스트리에 저장하고, 카프카에서 쓰는 레코드에는 스키마의 고유 식별자만 심어주면 된다.
- 컨슈머는 이 식별자를 사용해서 레지스트리에서 스키마를 사져와서 데이터를 역직렬화 하면 된다.
- 카프카에서는 시리얼라이저 사용하듯이 에이브로 시리얼라이저를 사용하면 되므로 사용법도 간단하다.

![image](https://github.com/user-attachments/assets/e889958e-c71c-46f1-84b4-ee69e2fce9f2)



